= CS3223 Project
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]

Project Team Members:

* Chua Wei Wen (A0156034M)
* Khor Shao Liang (A0160529E)
* Sim Kwan Tiong, Damien (A0155983N)

== Introduction
This document provides information on the features that has been implemented into the query processing engine.

== Implementation
The following features are implemented:

=== Block-Nested Loop Join

=== External Sort

=== Sort-Merge Join

=== Distinct
The elimination of duplicated is implemented using a variant of optimized sort-based approach.
Given a relation `R`, the attributes of `R` are passed to `ExternalSort`.
Sorted runs are generated with the extracted attributes.
During the merging phase, the duplicates are removed with the following algorithm:

```
lastTupleAdded;
if (isDistinct) {
    if (current smallest tuple != lastTupleAdded) {
	    outputBuffer.add(current smallest tuple);
	    lastTupleAdded = current smallest tuple;
    } else {
        // Duplicates detected, ignore
    }
} else {
    outputBuffer.add(current smallest tuple);
}
```

Comparison of the tuples are based on the extracted attributes.
The comparator is modified such that if the SQL query contains `DISTINCT`
the comparator will take in the flag and the extracted attributes that appear in the `DISTINCT` clause.
Hence, when it compares the tuples it will compare the tuple based on the attributes.
The modification of the override `compare()` method is as follows:

```
if (isDistinct) {
    boolean hasSameAttr = true;
    int finalComparisonResult = 0;
    Vector attList = joinAttributes;
    for (int i = 0; i < attList.size(); i++) {
        int index = schema.indexOf((Attribute) attList.get(i));
        int result = Tuple.compareTuples(t1, t2, index);
        finalComparisonResult = result;

        if (result != 0) {
            hasSameAttr = false;
            break;
        }
    }
    return hasSameAttr ? 0 : finalComparisonResult;
}
```

For example, given a relation `R(firstname, lastname, age, allowance)` and three tuples,
with the extracted attributes `firstname`, `lastname` and `age`;

```
- Tuple A(John, Doe, 18, 500),
- Tuple B(John, Toh, 18, 500) and
- Tuple C(John, Doe, 18, 600)
```

Based on the three extracted attributes `A` is equal to `C`, `A` is not equal to `B` and `B` is not equal to `C`.

=== Greedy Optimizer
